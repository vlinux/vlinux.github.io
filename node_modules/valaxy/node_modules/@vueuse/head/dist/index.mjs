// src/index.ts
import {
  inject,
  onBeforeUnmount as onBeforeUnmount2,
  watchEffect as watchEffect2
} from "vue";

// src/constants.ts
var PROVIDE_KEY = "usehead";
var HEAD_COUNT_KEY = "head:count";
var HEAD_ATTRS_KEY = "data-head-attrs";
var SELF_CLOSING_TAGS = ["meta", "link", "base"];
var BODY_TAG_ATTR_NAME = "data-meta-body";

// src/utils.ts
import { resolveUnref } from "@vueuse/shared";
import { unref } from "vue";
var sortTags = (aTag, bTag) => {
  const tagWeight = (tag) => {
    if (tag.props.renderPriority)
      return tag.props.renderPriority;
    switch (tag.tag) {
      case "base":
        return -1;
      case "meta":
        if (tag.props.charset)
          return -2;
        if (tag.props["http-equiv"] === "content-security-policy")
          return 0;
        return 10;
      default:
        return 10;
    }
  };
  return tagWeight(aTag) - tagWeight(bTag);
};
var tagDedupeKey = (tag) => {
  if (!["meta", "base", "script", "link"].includes(tag.tag))
    return false;
  const { props, tag: tagName } = tag;
  if (tagName === "base")
    return "base";
  if (tagName === "link" && props.rel === "canonical")
    return "canonical";
  if (props.charset)
    return "charset";
  const name = ["key", "id", "name", "property", "http-equiv"];
  for (const n of name) {
    let value;
    if (typeof props.getAttribute === "function" && props.hasAttribute(n))
      value = props.getAttribute(n);
    else
      value = props[n];
    if (value !== void 0) {
      return `${tagName}-${n}-${value}`;
    }
  }
  return false;
};
function resolveUnrefDeeply(ref2) {
  const root = resolveUnref(ref2);
  if (!ref2 || !root)
    return root;
  if (Array.isArray(root))
    return root.map(resolveUnrefDeeply);
  if (typeof root === "object") {
    return Object.fromEntries(
      Object.entries(root).map(([key, value]) => {
        if (key === "titleTemplate")
          return [key, unref(value)];
        return [
          key,
          resolveUnrefDeeply(value)
        ];
      })
    );
  }
  return root;
}
function resolveHeadInput(obj) {
  return resolveUnrefDeeply(obj);
}

// src/dom/create-element.ts
var createElement = (tag, attrs, document) => {
  const el = document.createElement(tag);
  for (const key of Object.keys(attrs)) {
    if (key === "body" && attrs.body === true) {
      el.setAttribute(BODY_TAG_ATTR_NAME, "true");
    } else {
      const value = attrs[key];
      if (key === "renderPriority" || key === "key" || value === false)
        continue;
      if (key === "children")
        el.textContent = value;
      else
        el.setAttribute(key, value);
    }
  }
  return el;
};

// src/dom/utils.ts
function isEqualNode(oldTag, newTag) {
  if (oldTag instanceof HTMLElement && newTag instanceof HTMLElement) {
    const nonce = newTag.getAttribute("nonce");
    if (nonce && !oldTag.getAttribute("nonce")) {
      const cloneTag = newTag.cloneNode(true);
      cloneTag.setAttribute("nonce", "");
      cloneTag.nonce = nonce;
      return nonce === oldTag.nonce && oldTag.isEqualNode(cloneTag);
    }
  }
  return oldTag.isEqualNode(newTag);
}
var setAttrs = (el, attrs) => {
  const existingAttrs = el.getAttribute(HEAD_ATTRS_KEY);
  if (existingAttrs) {
    for (const key of existingAttrs.split(",")) {
      if (!(key in attrs))
        el.removeAttribute(key);
    }
  }
  const keys = [];
  for (const key in attrs) {
    const value = attrs[key];
    if (value == null)
      continue;
    if (value === false)
      el.removeAttribute(key);
    else
      el.setAttribute(key, value);
    keys.push(key);
  }
  if (keys.length)
    el.setAttribute(HEAD_ATTRS_KEY, keys.join(","));
  else
    el.removeAttribute(HEAD_ATTRS_KEY);
};

// src/dom/update-elements.ts
var updateElements = (document = window.document, type, tags) => {
  var _a, _b;
  const head = document.head;
  const body = document.body;
  let headCountEl = head.querySelector(`meta[name="${HEAD_COUNT_KEY}"]`);
  const bodyMetaElements = body.querySelectorAll(`[${BODY_TAG_ATTR_NAME}]`);
  const headCount = headCountEl ? Number(headCountEl.getAttribute("content")) : 0;
  const oldHeadElements = [];
  const oldBodyElements = [];
  if (bodyMetaElements) {
    for (let i = 0; i < bodyMetaElements.length; i++) {
      if (bodyMetaElements[i] && ((_a = bodyMetaElements[i].tagName) == null ? void 0 : _a.toLowerCase()) === type)
        oldBodyElements.push(bodyMetaElements[i]);
    }
  }
  if (headCountEl) {
    for (let i = 0, j = headCountEl.previousElementSibling; i < headCount; i++, j = (j == null ? void 0 : j.previousElementSibling) || null) {
      if (((_b = j == null ? void 0 : j.tagName) == null ? void 0 : _b.toLowerCase()) === type)
        oldHeadElements.push(j);
    }
  } else {
    headCountEl = document.createElement("meta");
    headCountEl.setAttribute("name", HEAD_COUNT_KEY);
    headCountEl.setAttribute("content", "0");
    head.append(headCountEl);
  }
  let newElements = tags.map((tag) => ({
    element: createElement(tag.tag, tag.props, document),
    body: tag.props.body ?? false
  }));
  newElements = newElements.filter((newEl) => {
    for (let i = 0; i < oldHeadElements.length; i++) {
      const oldEl = oldHeadElements[i];
      if (isEqualNode(oldEl, newEl.element)) {
        oldHeadElements.splice(i, 1);
        return false;
      }
    }
    for (let i = 0; i < oldBodyElements.length; i++) {
      const oldEl = oldBodyElements[i];
      if (isEqualNode(oldEl, newEl.element)) {
        oldBodyElements.splice(i, 1);
        return false;
      }
    }
    return true;
  });
  oldBodyElements.forEach((t) => {
    var _a2;
    return (_a2 = t.parentNode) == null ? void 0 : _a2.removeChild(t);
  });
  oldHeadElements.forEach((t) => {
    var _a2;
    return (_a2 = t.parentNode) == null ? void 0 : _a2.removeChild(t);
  });
  newElements.forEach((t) => {
    if (t.body === true)
      body.insertAdjacentElement("beforeend", t.element);
    else
      head.insertBefore(t.element, headCountEl);
  });
  headCountEl.setAttribute(
    "content",
    `${headCount - oldHeadElements.length + newElements.filter((t) => !t.body).length}`
  );
};

// src/components.ts
import { defineComponent, onBeforeUnmount, ref, watchEffect } from "vue";
var addVNodeToHeadObj = (node, obj) => {
  const type = node.type === "html" ? "htmlAttrs" : node.type === "body" ? "bodyAttrs" : node.type;
  if (typeof type !== "string" || !(type in obj))
    return;
  const props = {
    ...node.props,
    children: Array.isArray(node.children) ? node.children[0].children : node.children
  };
  if (Array.isArray(obj[type]))
    obj[type].push(props);
  else if (type === "title")
    obj.title = props.children;
  else
    obj[type] = props;
};
var vnodesToHeadObj = (nodes) => {
  const obj = {
    title: void 0,
    htmlAttrs: void 0,
    bodyAttrs: void 0,
    base: void 0,
    meta: [],
    link: [],
    style: [],
    script: [],
    noscript: []
  };
  for (const node of nodes) {
    if (typeof node.type === "symbol" && Array.isArray(node.children)) {
      for (const childNode of node.children)
        addVNodeToHeadObj(childNode, obj);
    } else {
      addVNodeToHeadObj(node, obj);
    }
  }
  return obj;
};
var Head = /* @__PURE__ */ defineComponent({
  name: "Head",
  setup(_, { slots }) {
    const head = injectHead();
    let obj;
    onBeforeUnmount(() => {
      if (obj) {
        head.removeHeadObjs(obj);
        head.updateDOM();
      }
    });
    return () => {
      watchEffect(() => {
        if (!slots.default)
          return;
        if (obj)
          head.removeHeadObjs(obj);
        obj = ref(vnodesToHeadObj(slots.default()));
        head.addHeadObjs(obj);
        if (typeof window !== "undefined")
          head.updateDOM();
      });
      return null;
    };
  }
});

// src/ssr/stringify-attrs.ts
var stringifyAttrName = (str) => str.replace(/[\s"'><\/=]/g, "").replace(/[^a-zA-Z0-9_-]/g, "");
var stringifyAttrValue = (str) => str.replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
var stringifyAttrs = (attributes) => {
  const handledAttributes = [];
  for (const [key, value] of Object.entries(attributes)) {
    if (key === "children" || key === "key")
      continue;
    if (value === false || value == null)
      continue;
    let attribute = stringifyAttrName(key);
    if (value !== true)
      attribute += `="${stringifyAttrValue(String(value))}"`;
    handledAttributes.push(attribute);
  }
  return handledAttributes.length > 0 ? ` ${handledAttributes.join(" ")}` : "";
};

// src/ssr/index.ts
var tagToString = (tag) => {
  let isBodyTag = false;
  if (tag.props.body) {
    isBodyTag = true;
    delete tag.props.body;
  }
  if (tag.props.renderPriority)
    delete tag.props.renderPriority;
  const attrs = stringifyAttrs(tag.props);
  if (SELF_CLOSING_TAGS.includes(tag.tag)) {
    return `<${tag.tag}${attrs}${isBodyTag ? `  ${BODY_TAG_ATTR_NAME}="true"` : ""}>`;
  }
  return `<${tag.tag}${attrs}${isBodyTag ? ` ${BODY_TAG_ATTR_NAME}="true"` : ""}>${tag.props.children || ""}</${tag.tag}>`;
};
var renderHeadToString = (head) => {
  const tags = [];
  let titleTag = "";
  const htmlAttrs = {};
  const bodyAttrs = {};
  const bodyTags = [];
  for (const tag of head.headTags.sort(sortTags)) {
    if (tag.tag === "title")
      titleTag = tagToString(tag);
    else if (tag.tag === "htmlAttrs")
      Object.assign(htmlAttrs, tag.props);
    else if (tag.tag === "bodyAttrs")
      Object.assign(bodyAttrs, tag.props);
    else if (tag.props.body)
      bodyTags.push(tagToString(tag));
    else
      tags.push(tagToString(tag));
  }
  tags.push(`<meta name="${HEAD_COUNT_KEY}" content="${tags.length}">`);
  return {
    get headTags() {
      return titleTag + tags.join("");
    },
    get htmlAttrs() {
      return stringifyAttrs({
        ...htmlAttrs,
        [HEAD_ATTRS_KEY]: Object.keys(htmlAttrs).join(",")
      });
    },
    get bodyAttrs() {
      return stringifyAttrs({
        ...bodyAttrs,
        [HEAD_ATTRS_KEY]: Object.keys(bodyAttrs).join(",")
      });
    },
    get bodyTags() {
      return bodyTags.join("");
    }
  };
};

// src/index.ts
var injectHead = () => {
  const head = inject(PROVIDE_KEY);
  if (!head)
    throw new Error("You may forget to apply app.use(head)");
  return head;
};
var acceptFields = [
  "title",
  "meta",
  "link",
  "base",
  "style",
  "script",
  "noscript",
  "htmlAttrs",
  "bodyAttrs"
];
var renderTitleTemplate = (template, title) => {
  if (template == null)
    return "";
  if (typeof template === "function")
    return template(title);
  return template.replace("%s", title ?? "");
};
var headObjToTags = (obj) => {
  const tags = [];
  const keys = Object.keys(obj);
  const convertLegacyKey = (value) => {
    if (value.hid) {
      value.key = value.hid;
      delete value.hid;
    }
    if (value.vmid) {
      value.key = value.vmid;
      delete value.vmid;
    }
    return value;
  };
  for (const key of keys) {
    if (obj[key] == null)
      continue;
    switch (key) {
      case "title":
        tags.push({ tag: key, props: { children: obj[key] } });
        break;
      case "titleTemplate":
        break;
      case "base":
        tags.push({ tag: key, props: { key: "default", ...obj[key] } });
        break;
      default:
        if (acceptFields.includes(key)) {
          const value = obj[key];
          if (Array.isArray(value)) {
            value.forEach((item) => {
              const props = convertLegacyKey(item);
              tags.push({ tag: key, props });
            });
          } else if (value) {
            tags.push({ tag: key, props: convertLegacyKey(value) });
          }
        }
        break;
    }
  }
  return tags;
};
var createHead = (initHeadObject) => {
  let allHeadObjs = [];
  const previousTags = /* @__PURE__ */ new Set();
  const hookBeforeDomUpdate = [];
  const hookTagsResolved = [];
  if (initHeadObject)
    allHeadObjs.push(initHeadObject);
  const head = {
    install(app) {
      app.config.globalProperties.$head = head;
      app.provide(PROVIDE_KEY, head);
    },
    hookBeforeDomUpdate,
    hookTagsResolved,
    get headTags() {
      const deduped = [];
      const deduping = {};
      const resolvedHeadObjs = allHeadObjs.map(resolveHeadInput);
      const titleTemplate = resolvedHeadObjs.map((i) => i.titleTemplate).reverse().find((i) => i != null);
      resolvedHeadObjs.forEach((objs, headObjectIdx) => {
        const tags2 = headObjToTags(objs);
        tags2.forEach((tag, tagIdx) => {
          tag._position = headObjectIdx * 1e4 + tagIdx;
          if (titleTemplate && tag.tag === "title") {
            tag.props.children = renderTitleTemplate(
              titleTemplate,
              tag.props.children
            );
          }
          const dedupeKey = tagDedupeKey(tag);
          if (dedupeKey)
            deduping[dedupeKey] = tag;
          else
            deduped.push(tag);
        });
      });
      deduped.push(...Object.values(deduping));
      const tags = deduped.sort((a, b) => a._position - b._position);
      if (head.hookTagsResolved) {
        for (const k in head.hookTagsResolved)
          head.hookTagsResolved[k](tags);
      }
      return tags;
    },
    addHeadObjs(objs) {
      allHeadObjs.push(objs);
    },
    removeHeadObjs(objs) {
      allHeadObjs = allHeadObjs.filter((_objs) => _objs !== objs);
    },
    updateDOM(document = window.document) {
      let title;
      const htmlAttrs = {};
      const bodyAttrs = {};
      const actualTags = {};
      for (const tag of head.headTags.sort(sortTags)) {
        if (tag.tag === "title") {
          title = tag.props.children;
          continue;
        }
        if (tag.tag === "htmlAttrs") {
          Object.assign(htmlAttrs, tag.props);
          continue;
        }
        if (tag.tag === "bodyAttrs") {
          Object.assign(bodyAttrs, tag.props);
          continue;
        }
        actualTags[tag.tag] = actualTags[tag.tag] || [];
        actualTags[tag.tag].push(tag);
      }
      if (head.hookBeforeDomUpdate) {
        for (const k in head.hookBeforeDomUpdate) {
          const res = head.hookBeforeDomUpdate[k](actualTags);
          if (res === false)
            return;
        }
      }
      if (title !== void 0)
        document.title = title;
      setAttrs(document.documentElement, htmlAttrs);
      setAttrs(document.body, bodyAttrs);
      const tags = /* @__PURE__ */ new Set([...Object.keys(actualTags), ...previousTags]);
      for (const tag of tags)
        updateElements(document, tag, actualTags[tag] || []);
      previousTags.clear();
      Object.keys(actualTags).forEach((i) => previousTags.add(i));
    }
  };
  return head;
};
var IS_BROWSER = typeof window !== "undefined";
var useHead = (headObj) => {
  const head = injectHead();
  head.addHeadObjs(headObj);
  if (IS_BROWSER) {
    watchEffect2(() => {
      head.updateDOM();
    });
    onBeforeUnmount2(() => {
      head.removeHeadObjs(headObj);
      head.updateDOM();
    });
  }
};
export {
  Head,
  createElement,
  createHead,
  injectHead,
  isEqualNode,
  renderHeadToString,
  resolveHeadInput,
  setAttrs,
  sortTags,
  stringifyAttrName,
  stringifyAttrValue,
  stringifyAttrs,
  tagDedupeKey,
  tagToString,
  updateElements,
  useHead
};
